# Outline
### Interrupts
- Interrupt handling sequence
### Interrupt vector
- How does the system know where to go when an interrupt occurs?
### Coretex-M Nested Vector Interrupt Controller (NVIC)
- How to handle multiple concurrent interrupts?
### Polling vs. Interrupt
- Code examples

## Interrupts
* MCU can "sleep" or run other tasks 
* An interrupt is triggered when drop below a threshold
* MCU jumps into an interrupt handler, reads ADC once, checks the value, and reacts

- A signal to the CPU generated by hardware or software
- Makes the CPU to *suspend* normal program execution and perform some service related to the signal -> ***ISR***


## Polling 
**Polling**: Periodically checking to see if something is ready 
- e.g., waiting for switch input 

```
while(1) {
  outval = 0;
  inval = GPIOB_PDIR & 0x0C;
  if (inval & 0x8) outval = 0x0F;
  if (inval & 0x4) outval |= 0xF0; 
  GPIOD_PDOR = outval; 
  }
}
```

### Drawbacks
- Need to continually check (difficult to weave checks into complex code
- If the code becomes complex, might poll too slowly
- Can waste a lot of CPU time checking for very infrequent events

## I/O Handling with Interrupts
* An I/O pin requires a prompt reseponse from the CPU when an event occurs, even when the CPU is busy running a program. 

## Discussion Question 1
Which of the following best describes the ***sequence*** of actions that occur when a GPIO interrupt is triggered?

A. ISR runs immediately, then the CPU saves context <br>
B. The CPU finishes the main program before checking the interrupt <br>
C. The ISR replaces the current program permanently <br>
D. CPU saves context, jumps to ISR, executes ISR, restores context, resumes main program. 

> The correct answer is ***D***

### When a GPIO interrupt occurs:
1. CPU saves context - it automatically stores critical registers (like PC, status registersm, etc), so it can resume later 
2. Jumps to ISR (Interrupt Service Routine) - hardware redirects program flow to the ISR's address. 
3. Executes ISR - the ISR handles the interrupt (e.g., reads GPIO flag, clears it, etc). 
4. Restores context - CPU pops saved registers back 
5. Resumes main program exactly where it left off 

***A*** is wrong because the CPU saves context **before** running the ISR, otherwise it would lose its current execution state. 

## Interrupt Vector Table
The interrupt vector table is a lookup table stored in memory that tells the CPU which ISR function to execute for each specific interupt event. 

* The ***interrupt vector table*** is a special region in memory that the processor checks when an interrupt happens 
* It contains a list of addresses - one for each possible interrupt source
* Each entry in this table is called an interrupt vector 

| **Interrupt Source**         | **Vector Address** | **ISR Function**      |
| ---------------------------- | ------------------ | --------------------- |
| Reset                        | `0x00000004`       | `Reset_Handler()`     |
| NMI (Non-Maskable Interrupt) | `0x00000008`       | `NMI_Handler()`       |
| Hard Fault                   | `0x0000000C`       | `HardFault_Handler()` |
| GPIO Port A                  | `0x00000010`       | `PORTA_IRQHandler()`  |
| Timer Overflow               | `0x00000014`       | `Timer_ISR()`         |
| ADC Conversion Done          | `0x00000018`       | `ADC_ISR()`           |

## Discussion Question 2
Why does the interrupt vector table need to be located at a fixed memory address (like address 0x0000_0000 in Cortext-M)? 

A. To protect the vector table from being modified <br>
B. Because the vector table is stored in ROM <br>
C. So the CPU can locate the correct ISR immediately when an interrupt occurs <br>
D. Because the compiler generates it at a fixed location 

> The correct answer is ***C*** <br>
So the CPU can locate the ISR immediately when an interrupt occurs 

* When an interrupt is triggered, the CPU needs to know exactly where to look for the ISR address. 
* The hardware doesn't search or scan memory - it simply goes to a predefined location (like`0x00000000`), where the interrupt vector table begins 

### Why not A
> The key reason for a fixed address is hardware accessibility, not protection

## Interrupt Processing Sequence
1. Hardware needs service
2. Saves execution state
3. CPU jumps to a particular interrupt service routine (ISR)
4. ISR provides service
5. Restores execution state

## Instruction 'Fetch-Execute' Cycle
For every instruction, <br>
1. fetch instruction at PC (program counter)
2. decode the fetched instruction
3. execute the decoder instruction
4. advance PC to next instruction 
> Interrupt? 

if NO, repeat <br>
if YES, <br>
1. Save context
2. Find ISR (from intr vector)
3. Execute ISR
4. Restore Context 

## Interrupt Context Saving/Restoring
* Entering Interrupt Service Routine (ISR) 
K64F saves eight registers on entry of interrupt 

* Returning from ISR
Restores CPU registers from stack <br>
Makes K64F continue to execute the interrupted program unless there is another pending interrupt 

## Discussion Question 3
What makes hardware interrupts fundamentally different from function calls or software loops in a running program? <br>
A. Interrupts are triggered by user input only <br>
B. Interrupts execute only during initialization <br>
C. Interrupts are event-driven and can occur asynchronously, outside of the program flow <br>
D. Function calls and interrupts are handled indntically by the CPU

> Correct answer is C

### Explanation
* Function calls are synchronous - they happen only when your program tells them to 
* ***Interrupts***, however, are ***asynchronous*** - they can happen at any time, triggered by an external or internal hardware event (like a timer overflow, GPIO pin change, UART receive, ADC complete, etc) 

This means: <br>
1. The CPU can be running any part of the main program
2. A hardware event (interrupt) occurs, 
3. The CPU pauses the main program, saves context, and jumps to the interrupt service routine (ISR)
4. When the ISR finishes, it returns to the main program as if nothing happened

| **Concept**      | **Function Call**                                 | **Hardware Interrupt**                                                                          |
| ---------------- | ------------------------------------------------- | ----------------------------------------------------------------------------------------------- |
| **Trigger**      | Called explicitly in code                         | Triggered automatically by hardware or external events                                          |
| **Timing**       | Synchronous — part of normal program flow         | Asynchronous — can occur at any time                                                            |
| **Control**      | Software-controlled                               | Hardware-controlled                                                                             |
| **CPU Behavior** | Jumps to a known function within the program flow | Saves context, jumps to ISR (Interrupt Service Routine), then restores and resumes main program |
| **Example**      | `myFunction();`                                   | GPIO pin change, timer overflow, ADC conversion complete                                        |


